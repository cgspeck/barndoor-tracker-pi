{"version":3,"sources":["webpack:///./routes/align/style.css","webpack:///../node_modules/setimmediate/setImmediate.js","webpack:///../node_modules/timers-browserify/main.js","webpack:///../node_modules/webpack/buildin/global.js","webpack:///./routes/align/index.js"],"names":["module","exports","global","undefined","clearImmediate","handle","tasksByHandle","runIfPresent","currentlyRunningATask","setTimeout","task","callback","args","length","apply","run","setImmediate","registerImmediate","html","channel","messagePrefix","onGlobalMessage","nextHandle","doc","document","attachTo","Object","getPrototypeOf","toString","call","process","nextTick","postMessage","importScripts","postMessageIsAsynchronous","oldOnMessage","onmessage","canUsePostMessage","MessageChannel","port1","event","data","port2","createElement","documentElement","script","onreadystatechange","removeChild","appendChild","Math","random","source","indexOf","slice","addEventListener","attachEvent","Function","Array","arguments","i","self","this","Timeout","id","clearFn","_id","_clearFn","scope","window","prototype","clearTimeout","setInterval","clearInterval","timeout","close","unref","ref","enroll","item","msecs","_idleTimeoutId","_idleTimeout","unenroll","_unrefActive","active","_onTimeout","require","g","e","Align","state","locationSettings","latitude","alignStatus","azAligned","altAligned","currentAz","currentAlt","handleError","console","error","setState","statusLabel","azTarget","calculateAzTarget","azValue","indicator","toFixed","altValue","altTarget","abs","componentDidMount","getLocationSettings","then","r","log","timer","refreshAlignmentStatus","bind","catch","getAlignStatus","componentWillUnmount","render","class","style","align","label","value","readOnly","Component"],"mappings":"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","file":"3.c.js","sourcesContent":["// extracted by mini-css-extract-plugin\nmodule.exports = {\"align\":\"align__3YvuJ\",\"textField\":\"textField__3sCSg\"};","(function (global, undefined) {\n    \"use strict\";\n\n    if (global.setImmediate) {\n        return;\n    }\n\n    var nextHandle = 1; // Spec says greater than zero\n    var tasksByHandle = {};\n    var currentlyRunningATask = false;\n    var doc = global.document;\n    var registerImmediate;\n\n    function setImmediate(callback) {\n      // Callback can either be a function or a string\n      if (typeof callback !== \"function\") {\n        callback = new Function(\"\" + callback);\n      }\n      // Copy function arguments\n      var args = new Array(arguments.length - 1);\n      for (var i = 0; i < args.length; i++) {\n          args[i] = arguments[i + 1];\n      }\n      // Store and register the task\n      var task = { callback: callback, args: args };\n      tasksByHandle[nextHandle] = task;\n      registerImmediate(nextHandle);\n      return nextHandle++;\n    }\n\n    function clearImmediate(handle) {\n        delete tasksByHandle[handle];\n    }\n\n    function run(task) {\n        var callback = task.callback;\n        var args = task.args;\n        switch (args.length) {\n        case 0:\n            callback();\n            break;\n        case 1:\n            callback(args[0]);\n            break;\n        case 2:\n            callback(args[0], args[1]);\n            break;\n        case 3:\n            callback(args[0], args[1], args[2]);\n            break;\n        default:\n            callback.apply(undefined, args);\n            break;\n        }\n    }\n\n    function runIfPresent(handle) {\n        // From the spec: \"Wait until any invocations of this algorithm started before this one have completed.\"\n        // So if we're currently running a task, we'll need to delay this invocation.\n        if (currentlyRunningATask) {\n            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a\n            // \"too much recursion\" error.\n            setTimeout(runIfPresent, 0, handle);\n        } else {\n            var task = tasksByHandle[handle];\n            if (task) {\n                currentlyRunningATask = true;\n                try {\n                    run(task);\n                } finally {\n                    clearImmediate(handle);\n                    currentlyRunningATask = false;\n                }\n            }\n        }\n    }\n\n    function installNextTickImplementation() {\n        registerImmediate = function(handle) {\n            process.nextTick(function () { runIfPresent(handle); });\n        };\n    }\n\n    function canUsePostMessage() {\n        // The test against `importScripts` prevents this implementation from being installed inside a web worker,\n        // where `global.postMessage` means something completely different and can't be used for this purpose.\n        if (global.postMessage && !global.importScripts) {\n            var postMessageIsAsynchronous = true;\n            var oldOnMessage = global.onmessage;\n            global.onmessage = function() {\n                postMessageIsAsynchronous = false;\n            };\n            global.postMessage(\"\", \"*\");\n            global.onmessage = oldOnMessage;\n            return postMessageIsAsynchronous;\n        }\n    }\n\n    function installPostMessageImplementation() {\n        // Installs an event handler on `global` for the `message` event: see\n        // * https://developer.mozilla.org/en/DOM/window.postMessage\n        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages\n\n        var messagePrefix = \"setImmediate$\" + Math.random() + \"$\";\n        var onGlobalMessage = function(event) {\n            if (event.source === global &&\n                typeof event.data === \"string\" &&\n                event.data.indexOf(messagePrefix) === 0) {\n                runIfPresent(+event.data.slice(messagePrefix.length));\n            }\n        };\n\n        if (global.addEventListener) {\n            global.addEventListener(\"message\", onGlobalMessage, false);\n        } else {\n            global.attachEvent(\"onmessage\", onGlobalMessage);\n        }\n\n        registerImmediate = function(handle) {\n            global.postMessage(messagePrefix + handle, \"*\");\n        };\n    }\n\n    function installMessageChannelImplementation() {\n        var channel = new MessageChannel();\n        channel.port1.onmessage = function(event) {\n            var handle = event.data;\n            runIfPresent(handle);\n        };\n\n        registerImmediate = function(handle) {\n            channel.port2.postMessage(handle);\n        };\n    }\n\n    function installReadyStateChangeImplementation() {\n        var html = doc.documentElement;\n        registerImmediate = function(handle) {\n            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\n            var script = doc.createElement(\"script\");\n            script.onreadystatechange = function () {\n                runIfPresent(handle);\n                script.onreadystatechange = null;\n                html.removeChild(script);\n                script = null;\n            };\n            html.appendChild(script);\n        };\n    }\n\n    function installSetTimeoutImplementation() {\n        registerImmediate = function(handle) {\n            setTimeout(runIfPresent, 0, handle);\n        };\n    }\n\n    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.\n    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);\n    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;\n\n    // Don't get fooled by e.g. browserify environments.\n    if ({}.toString.call(global.process) === \"[object process]\") {\n        // For Node.js before 0.9\n        installNextTickImplementation();\n\n    } else if (canUsePostMessage()) {\n        // For non-IE10 modern browsers\n        installPostMessageImplementation();\n\n    } else if (global.MessageChannel) {\n        // For web workers, where supported\n        installMessageChannelImplementation();\n\n    } else if (doc && \"onreadystatechange\" in doc.createElement(\"script\")) {\n        // For IE 6–8\n        installReadyStateChangeImplementation();\n\n    } else {\n        // For older browsers\n        installSetTimeoutImplementation();\n    }\n\n    attachTo.setImmediate = setImmediate;\n    attachTo.clearImmediate = clearImmediate;\n}(typeof self === \"undefined\" ? typeof global === \"undefined\" ? this : global : self));\n","var scope = (typeof global !== \"undefined\" && global) ||\n            (typeof self !== \"undefined\" && self) ||\n            window;\nvar apply = Function.prototype.apply;\n\n// DOM APIs, for completeness\n\nexports.setTimeout = function() {\n  return new Timeout(apply.call(setTimeout, scope, arguments), clearTimeout);\n};\nexports.setInterval = function() {\n  return new Timeout(apply.call(setInterval, scope, arguments), clearInterval);\n};\nexports.clearTimeout =\nexports.clearInterval = function(timeout) {\n  if (timeout) {\n    timeout.close();\n  }\n};\n\nfunction Timeout(id, clearFn) {\n  this._id = id;\n  this._clearFn = clearFn;\n}\nTimeout.prototype.unref = Timeout.prototype.ref = function() {};\nTimeout.prototype.close = function() {\n  this._clearFn.call(scope, this._id);\n};\n\n// Does not start the time, just sets up the members needed.\nexports.enroll = function(item, msecs) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = msecs;\n};\n\nexports.unenroll = function(item) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = -1;\n};\n\nexports._unrefActive = exports.active = function(item) {\n  clearTimeout(item._idleTimeoutId);\n\n  var msecs = item._idleTimeout;\n  if (msecs >= 0) {\n    item._idleTimeoutId = setTimeout(function onTimeout() {\n      if (item._onTimeout)\n        item._onTimeout();\n    }, msecs);\n  }\n};\n\n// setimmediate attaches itself to the global object\nrequire(\"setimmediate\");\n// On some exotic environments, it's not clear which object `setimmediate` was\n// able to install onto.  Search each possibility in the same order as the\n// `setimmediate` library.\nexports.setImmediate = (typeof self !== \"undefined\" && self.setImmediate) ||\n                       (typeof global !== \"undefined\" && global.setImmediate) ||\n                       (this && this.setImmediate);\nexports.clearImmediate = (typeof self !== \"undefined\" && self.clearImmediate) ||\n                         (typeof global !== \"undefined\" && global.clearImmediate) ||\n                         (this && this.clearImmediate);\n","var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n","import { h, Component } from \"preact\";\nimport style from \"./style\";\n\nimport TextField from \"preact-material-components/TextField\";\nimport \"preact-material-components/TextField/style.css\";\n\nimport { getAlignStatus, getLocationSettings } from \"../../lib/settings\";\nimport { setInterval } from \"timers\";\n\nexport default class Align extends Component {\n  state = {\n    locationSettings: {\n      latitude: null\n    },\n    alignStatus: {\n      azAligned: null,\n      altAligned: null,\n      currentAz: null,\n      currentAlt: null\n    }\n  };\n\n  async componentDidMount() {\n    getLocationSettings()\n      .then(r => {\n        this.setState({ locationSettings: { ...r } });\n        console.log(\"Starting Interval\");\n        this.timer = setInterval(this.refreshAlignmentStatus.bind(this), 500);\n      })\n      .catch(e => this.handleError(e));\n  }\n\n  handleError = e => {\n    console.error(\"problem\", e);\n    this.setState({ error: e });\n  };\n\n  async refreshAlignmentStatus() {\n    getAlignStatus().then(r => this.setState({ alignStatus: { ...r } }));\n  }\n\n  componentWillUnmount() {\n    console.log(\"Clearing timer\");\n    clearInterval(this.timer._id);\n  }\n\n  statusLabel = (azAligned, altAligned) => {\n    if (azAligned && altAligned) {\n      return <h2>Aligned</h2>;\n    }\n    return <h2>Not Aligned</h2>;\n  };\n\n  azTarget = azTarget => {\n    if (azTarget !== null) {\n      return `AZ target: ${azTarget}`;\n    }\n  };\n\n  calculateAzTarget = latitude => {\n    if (latitude === null) return null;\n\n    if (latitude < 0) {\n      return 180;\n    } else {\n      return 0;\n    }\n  };\n\n  azValue = (azTarget, currentAz, azAligned) => {\n    if (azTarget !== null && currentAz !== null && azAligned !== null) {\n      let indicator;\n\n      if (azAligned) {\n        indicator = \"✔\";\n      } else if (azTarget == 180) {\n        indicator = currentAz < azTarget ? \"✘ >>\" : \"✘ <<\";\n      } else {\n        indicator = currentAz > 180 ? \"✘ >>\" : \"✘ <<\";\n      }\n\n      return `${currentAz.toFixed(2)} ${indicator}`;\n    }\n  };\n\n  altValue = (latitude, currentAlt, altAligned) => {\n    if (latitude !== null && currentAlt !== null && altAligned !== null) {\n      const altTarget = Math.abs(latitude);\n      let indicator;\n\n      if (altAligned) {\n        indicator = \"✔\";\n      } else {\n        indicator = currentAlt > altTarget ? \"✘ ▼▼\" : \"✘ ▲▲\";\n      }\n\n      return `${currentAlt.toFixed(2)} ${indicator}`;\n    }\n  };\n\n  altTarget = latitude => {\n    if (latitude !== null) {\n      const targetVal = Math.abs(latitude);\n\n      return `Alt target: ${targetVal}`;\n    }\n  };\n\n  render({}, { locationSettings, alignStatus }) {\n    const { azAligned, altAligned, currentAz, currentAlt } = alignStatus;\n    const { latitude, azError } = locationSettings;\n\n    const azTarget = this.calculateAzTarget(latitude);\n\n    return (\n      <div class={style.align}>\n        <h1>Align</h1>\n        {this.statusLabel(azAligned, altAligned)}\n        <div>\n          <p>\n            <TextField\n              label=\"Azimuth\"\n              value={this.azValue(azTarget, currentAz, azAligned)}\n              readOnly\n            ></TextField>\n            <br />\n            {this.azTarget(azTarget)}\n          </p>\n          <p>\n            <TextField\n              label=\"Altitude\"\n              value={this.altValue(latitude, currentAlt, altAligned)}\n              readOnly\n            ></TextField>\n            <br />\n            {this.altTarget(latitude)}\n          </p>\n        </div>\n      </div>\n    );\n  }\n}\n"],"sourceRoot":""}